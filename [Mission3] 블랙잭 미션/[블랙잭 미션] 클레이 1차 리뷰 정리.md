# 책임을 정확하게 할당하자!

```java
public class Cards {
    //생략
    public boolean canReceiveCard() {
        return getSum() < BLACK_JACK_SCORE;
    }
}
```

과연 이 부분이 보유한 카드의 역할인지 생각해보자.
특히 딜러의 경우는 카드 합이 16인지 검증해야 하는데 이걸 보유한 카드의 역할이라고 가정하면,
보유한 카드는 딜러의 카드합을 확인하는 메서드와 플레이어의 카드합을 확인하는 메서드 두가지가 있어야 한다.

그러나 이 역할을 참여자(딜러와 플레이어의 추상화)의 역할로 넘기게 되면, 카드를 더 받아야 되는지를 딜러와 플레이어가 자기 사정에 맞게 역할을 수행하면 된다. (그 대신 보유한 카드 합을 넘겨줘야 한다.)

# Integer 의 비교 연산

Integer는 일반적으로 >, <, ==와 같은 비교 연산자로 비교 할 수 있다.
그러나 ==연산시에는 주의해야 한다.

JVM은 Integer 내부에 자주 사용되는 값 일부를 캐싱해놓는다.
-128 ~ 127 사이의 값은 Integer내부에 Integer 배열로 저장해놓는다.

```java
 private static class IntegerCache 
 {
   private IntegerCache(){}
   
   static final Integer cache[] = new Integer[-(-128) + 127 + 1];
 
   static 
   {
     for(int i = 0; i < cache.length; i++)
     cache[i] = new Integer(i - 128); 
   }
 }
    
 public static Integer valueOf(int i) 
 {
	final int offset = 128;
	if (i >= -128 && i <= 127) // must cache 
        { 
	    return IntegerCache.cache[i + offset];
	}
        return new Integer(i);
 }
```

-128과 127 사이의 값은 Integer 내부에서 캐시된 객체를 반환한다.
같은 객체를 ==로 비교하니 당연히 참이 된다.

```java
Integer myNumber = 10;
Integer myNumber2 = Integer.valueOf(10);
assertThat(myNumber == myNumber2).isTrue(); //통과
```

128 이상의 수를 Integer로 비교하면 두 객체가 새롭게 만들어진 객체이므로, ==로 비교하면 서로 다른 참조값이므로
내부에 같은 수를 가져도 거짓으로 판별된다.

```java
Integer ten = 128;
Integer ten2 = Integer.valueOf(128);
assertThat(ten == ten2).isTrue(); //통과 실패!!!
```

따라서 == 보다는 equals를 사용하는게 맞다!

```java
Integer ten = 128;
Integer ten2 = Integer.valueOf(128);
assertThat(ten.equals(ten2)).isTrue();
```

