
> # 피드백을 주고받은 PR
> - [[1단계 - 블랙잭] 렉스(오성원) 미션 제출합니다. #257](https://github.com/woowacourse/java-blackjack/pull/257)
> - [작성한 미션 코드](https://github.com/Seongwon97/java-blackjack/tree/step1)

# 피드백 정리
## 1. 상황에 맞는 적절한 예외를 던지자
- [코멘트 링크](https://github.com/woowacourse/java-blackjack/pull/257#discussion_r825255644)

```java
public class Deck {
  ...
    public Card drawCard() {
        if (cards.isEmpty()) {
//            throw new IllegalStateException(ERROR_EMPTY_DECK);
            throw new IndexOutOfBoundsException(ERROR_EMPTY_DECK);
        }
        return cards.poll();
    }
  ...
}
```
저는 지금까지 앞선 미션을 진행하면서는 발생하는 예외상황들을 모두 `IllegalArgumentException`을 사용하였습니다.
그러면 좋지 않다는 것을 알면서도..상황별로 어떤 예외를 쓰는 것이 올바른지 모르기에 그랬던 것 같습니다😅

이번 피드백으로 상황별로 적절한 예외를 발생시켜주는 것이 좋을 것 같다는 피드백을 받아 상황별 필요한 예외에 대해 학습할 수 있었습니다. 이것만으로도

> 학습자료
> - [Effective Java Item72. 표준 예외를 사용하라](https://jaehun2841.github.io/2019/03/10/effective-java-item72/#%ED%91%9C%EC%A4%80-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
    > 자세한 내용은 이펙티브자바 Item72부분을 참고하시면 될 것 같습니다.

## 2. 인스턴스를 생성할 일이 없는 상속용 클래스는 추상 클래스로 만들어라
- [코멘트 링크](https://github.com/woowacourse/java-blackjack/pull/257#discussion_r825255742)

해당 피드백은 아직까지 상속에 대한 지식이 부족하여 받은 피드백입니다.

추상 메서드가 없는 클래스이더라도 상속만을 위해 사용하는 클래스들은 `abstract`를 붙여줌으로써
프로그램 내에서 해당 클래스의 인스턴스 생성을 막아줄 수 있습니다.

> 학습 정리 자료
> - [Rex's Develop Diary - 자바의 상속](https://seongwon97.github.io/posts/%EC%9E%90%EB%B0%94-%EC%83%81%EC%86%8D/)

## 3. View에서는 도메인의 메인 로직을 실행시키지 말자
- [코멘트 링크](https://github.com/woowacourse/java-blackjack/pull/257#discussion_r825258979)

```java
public class OutputView {
  ...
    public static void printFinalScore(DealerResult result, Users users, int dealerSum) {
        printDealerResult(result.getCount());

        for (User user : users.getUsers()) {
            printUserResult(user, user.checkResult(dealerSum));
        }
      ...
    }
  ...
}
```

해당 피드백은 승패를 계산하는 `checkResult()`와 같은 핵심 메서드가 도메인, 컨트롤러가 아닌 뷰에서 호출되어 사용되었기에 받은 피드백입니다.

저는 해당 피드백을 고치기 위해 DTO를 생성하여 도메인 또는 컨트롤러에서 실질적인 핵심 로직을 실행시킨 후, DTO를 통해 결과를 반환하고 뷰에서는
받은 결과를 출력하는 작업만 하도록 수정하였습니다.

## 4. Domain에는 View와 관련된 내용이 없도록 신경쓰자
- [코멘트 링크](https://github.com/woowacourse/java-blackjack/pull/257#discussion_r825259337)

```java
public enum CardNumber {
    ACE(11, "A"),
    TWO(2, "2"),
    THREE(3, "3"),
    FOUR(4, "4"),
    FIVE(5, "5"),
    SIX(6, "6"),
    SEVEN(7, "7"),
    EIGHT(8, "8"),
    NINE(9, "9"),
    TEN(10, "10"),
    JACK(10, "J"),
    QUEEN(10, "Q"),
    KING(10, "K");

    private final int number;
    private final String originalName;
  ...
```
아마 대부분의 사람들이 이번 미션을 진행하며 카드의 타입과 번호를 다음과 같이 enum타입으로 도메인 부분에 생성하여 사용했을 것입니다.

<img src="https://seongwon97.github.io/assets/img/2022-03-13-%ED%94%BC%EB%93%9C%EB%B0%B14.png">

하지만 위의 피드백을 받고 `현재 코드는 카드 출력의 형식을 변경한다면 view가 아닌 domain을 수정해야 한다!`는 사실을 꺠닫게 되며,
`originalName`의 경우는 도메인이 아닌 뷰에 위치하는 것이 MVC입장에서는 맞다 생각했습니다.

그래서 저는 뷰에 아래의 `OriginalCardNumber`, `OriginalCardType`이라는 클래스를 생성하여 카드 타입,번호를 받고 그에 맞는 출력 타입을 반환하도록 코드를 수정했습니다.

```java
public enum OriginalCardType {

    HEART(CardType.HEART, "하트"),
    DIAMOND(CardType.DIAMOND, "다이아몬드"),
    SPADE(CardType.SPADE, "스페이드"),
    CLOVER(CardType.CLOVER, "클로버");

    private final CardType cardType;
    private final String name;

    OriginalCardType(CardType cardType, String name) {
        this.cardType = cardType;
        this.name = name;
    }

    public static String getOriginalName(CardType cardType) {
        return Arrays.stream(values())
                .filter(c -> c.getCardType() == cardType)
                .map(OriginalCardType::getName)
                .findAny()
                .orElseThrow(NullPointerException::new);
    }

    private CardType getCardType() {
        return cardType;
    }

    private String getName() {
        return name;
    }
}
```

이 외에는 네이밍, 접근제어자 관련 간단한 피드백을 받은 것 같습니다.
